1. **工厂方法模式** 抽出公共类，公共类中规定了通用方法以及其返回类型，新实例通过公共类创建并且重写其中的通用方法来满足特定逻辑，但返回的类型得基于公共类中规定的返回
2. 原型方法模式 在原型中实现 clone 方法，生成新实例时通过原型的 clone 方法复制当前实例的属性
3. **抽象工厂模式** 只规定了接口，具体实现由子类实现，子类实现了接口的方法，但是返回的类型是子类自己的类型。与工厂模式相比，抽象工厂模式更加抽象，适合创建一组相关或相互依赖的对象
4. 生成器模式 将一整个对象的创建过程拆分成多个步骤，每个步骤都有一个生成器，最后将这些生成器组合成一个对象，控制生成器组合顺序直至生产完成的类称为主管类。可以按需控制生成器的组合顺序，重点关注如何分步生成复杂对象
5. **单例模式** 保证一个类只有一个实例(初始化时生成，之后都用该实例)，为该实例提供一个全局访问节点，适用于需要严格地控制全局变量的场景
6. **适配器模式** 将原本不兼容的接口转换成兼容的接口，适用于需要复用一些现有的类，但是接口与现有系统不兼容的场景，例如 dto(data transfer object)转换,将自定义结构对象和 sql 数据对象转换
7. **装饰模式** 动态地给一个对象添加或删除一些额外的职责，适用于需要扩展类的功能或给类添加责任的场景，例如 vue 的 mixin 和 react 的高阶组件，与责任链模式不同的是，装饰器模式不能中断请求的传递。
8. **代理模式** 通过代理对象来控制对真实对象的访问，适用于延迟初始化（虚拟代理），缓存请求结果（缓存代理）以及需要控制对真实对象的访问权限的场景，例如懒加载，远程代理等
9. **责任链模式** 将请求沿着树的深度方向传递处理形成一条链，每个步骤都可以处理请求，也可以拒绝请求，不再处理后续步骤。
10. **命令模式** 命令通常是一个封装了抽象操作的类或对象，不参与具体业务处理，负责请求的传递和添加额外参数，可以实现撤销和恢复功能，适用于需要将请求发送者和请求接收者解耦的场景，如 addEventListener。先定义命令接口，再实现具体命令并调用接受者，接受者执行具体命令。
11. 迭代器模式 提供一种方法顺序访问一个集合中的各个元素，而又不暴露该对象的内部表示，适用于需要解耦遍历集合的场景，如数组，链表等。先定义迭代器接口，再声明集合接口以及其中一个获取迭代器的方法，再实现具体迭代器并调用集合迭代器，聚合对象执行具体迭代器。
12. **观察者模式** 定义了一种一对多的依赖关系，当一个对象(发布者)的状态发生变化时，所有依赖于它的对象(订阅者)都得到通知并被自动更新，适用于需要在一个对象状态发生变化时通知其他对象的场景，如 vue 的 watch 和 react 的 useEffect。先定义观察者接口，再实现具体观察者并调用主题，主题执行具体观察者。
13. **策略模式** 先定义策略接口，再将每个算法封装起来实现策略，并使它们可以互换，适用于需要在运行时选择算法的场景，最后由上下文执行这个策略，客户端调用上下文并决定采取哪个具体策略，因此上下文不清楚采用了具体哪个策略，由客户端选择。如排序算法，压缩算法等。

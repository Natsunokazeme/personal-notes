# _图像加载太慢_

    1.  可以使用懒加载,即当图像进入可视区域时,再加载图像(html5 中 img 标签 有 loading lazy 直接实现) 前端级别
    2.  预加载,即提前加载图像 前端级别
    3.  预览图,即先加载一张缩略图,然后再加载完整图像 后端级别
    4.  调整图像分辨率,即根据显示图像的大小,加载合适的图像
    5.  图像压缩,即减少图像的大小
    6.  图像 CDN 加速,即使用 CDN 加速图像加载 后端级别
    7.  图像缓存,即使用浏览器缓存图像,通过设置响应头的 Cache-Control 和 Expires 字段来实现(该方法能缓存比 localStorage 更多的数据并且加载更快)

# _如何优化页面的加载速度_

总结：1.网络原理 2.资源引入 3.代码
1、网络原理 服务器响应时间:有独立的服务器,提高 Web 服务器的质量,移除不必要的插件
2、网络原理 浏览器缓存 :减少 HTTP 请求,从而提高网站加载速度
3、资源引入 gzip 压缩:它的工作原理是在发送 HTML 和 CSS 文件到浏览器之前压缩文件大小
4、异步脚本:网页负载就不必依赖于这些异步脚本
5、网络原理 内容分发网络（CDN）:CDN 是位于不同地理位置的服务器组成的网络。每个服务器都拥有所有网站的文件副本。有网站访问者请求文件和网页时就可以直接从就近网站服务器发送过来（也可以是从负载最小的服务器）
6、优化 JavaScript、HTML 和 CSS:删除所有不必要的空 格和注释从而减小文件大小
7、资源引入 置于顶部的样式表和底部的脚本
8、资源引入 避免阻塞型的 JavaScript 和 CSS
9、资源引入 JavaScript 的延迟解析
10、启用 Keep Alive:用户请求网页时浏览器首先需访问 HTML 文件,然后它才读取这些文件,并请求与其他资料相关联。如果“Keep Alive”选项被禁止,下载网站的进程就会增加从而拖累网站速度。启用 KeepAlive 的另一个好处是,可以减少 CPU 使用
11、图像和文件格式:建议使用 JPEG 格式,而不是 GIF 和 PNG 图像,除非图像包含 Alpha 因子或者是透明的
12、优化代码：不使用内联 CSS
13、资源引入 文件分离:可以增加并行下载的数量
14、网络原理 尽量减少 HTTP 请求:减少网站上的对象数量；最小化网站上的重定向数量；使用 CSS Sprites 技术；结合 JavaScripts 和 CSS
15、资源引入 去掉不必要的插件
16、网络原理 减少 DNS 查询(DNS lookups)

# _一个页面从输入 url 到加载完成的过程都发生了什么,请详细说明_

1. 首先,在浏览器地址栏中输入 url,浏览器解析出域名
2. 浏览器先查看浏览器缓存-系统缓存-路由器缓存,如果缓存中没有对应 ip,会按域名服务器顺序向域名服务器发送查询请求,直到查到结果,如果找不到 ip,浏览器会报错。
3. 浏览器根据 ip 地址向服务器发起 tcp 连接,与浏览器建立 tcp 三次握手
4. 握手成功后,浏览器向服务器发送 http 请求,请求数据包，若为 https 协议，会进行 ssl 握手
5. 服务器处理收到的请求,处理完成后将数据返回至浏览器
6. 浏览器收到 HTTP 响应,开始解析 html 源码,发现 head 里有个 base 标签,里面有个 url,于是又发起了一个请求.
7. 浏览器解析完成后渲染页面:生成 Dom 树、解析 css 样式、js 交互

# _浏览器渲染过程_

浏览器渲染的过程主要包括以下五步：

1. 浏览器将获取的 HTML 文档解析成 DOM 树。
2. 处理 CSS 标记,构成层叠样式表模型 CSSOM(CSS Object Model)。
3. 将 DOM 和 CSSOM 合并为渲染树(rendering tree),代表一系列将被渲染的对象。
   渲染树的每个 renderer 包含一个 dom 对象和计算过的样式规则,它被称之为布局 layout。具体显示的时候，每一个 renderer 都相当于一个矩形区域，即 css 盒子模型的概念
4. 布局阶段 浏览器使用一种流式处理的方法,只需要一次绘制操作就可以布局所有的元素，此阶段所有相对值都会转化为屏幕上的绝对值。
5. 绘制 将渲染树的各个节点绘制到屏幕上,这一步被称为绘制 painting。

场景题 tips

1. 场景 富文本 是一种可以设置字体，颜色，大小，样式，甚至可以插入图片，链接等的文本
2. 场景 前端攻击方法：XSS，CSRF，点击劫持，SQL 注入，DDOS，DNS 劫持，中间人攻击。
3. 场景 canvas 大量渲染优化

   1. 只渲染可视区域，通过监听滚动事件，判断滚动条的位置，只渲染可视区域的内容
   2. 图像压缩，通过 canvas 的 drawImage 方法的第三个参数，可以对图像进行压缩，第三个参数为一个对象，包含 width 和 height 属性，可以设置图像的宽高，若不设置，则默认为图像的原始宽高
   3. GPU 加速
   4. WebGL 绘制图形代替 canvas(类似开启 GPU 加速)
   5. three.js 代替 canvas

4. 场景 单页面应用和多页面应用的区别：单页面应用只有一个 html 页面，所有的页面都是在这个页面上切换，多页面应用有多个 html 页面，每个页面都是一个独立的页面，有自己的根模块。切换页面时，会重新加载页面，单页面应用的优点是页面切换快，用户体验好，缺点是首屏加载慢，多页面应用的优点是首屏加载快，缺点是页面切换慢，用户体验差。
5. 场景 页面监控 数据埋点
   1. FPS(frame per second) 每秒帧数,一般 60 帧为流畅,低于 30 帧为卡顿,通过 requestAnimationFrame 来获取每一帧的时间,计算是否掉帧
   2. Performance API,通过 performance.timing 来获取页面加载时间,通过 performance.getEntries()来获取页面资源加载时间,通过 performance.memory 来获取页面内存使用情况
   3. PerformanceObserver API,通过 performanceObserver 来监听页面性能,通过 performanceObserver.observe()来监听页面性能,通过 performanceObserver.disconnect()来停止监听页面性能
   4. navigation.connection,通过 navigator.connection 来获取网络连接信息,通过 navigator.onLine 来判断当前是否联网

# 实现页面懒加载的方式有哪些

1. 通过 IntersectionObserver API 来实现页面懒加载,IntersectionObserver 是一个构造函数,接受两个参数,第一个参数是一个回调函数,当被观察的元素与视口发生交叉时,会触发这个回调函数,第二个参数是一个对象,包含 root,rootMargin 和 threshold 三个属性,root 是一个 DOM 节点,用来指定根元素,rootMargin 是一个字符串,用来指定根元素的边距,threshold 是一个数组,用来指定交叉比例,当被观察元素的交叉比例达到这个值时,会触发回调函数
2. 通过 getBoundingClientRect 方法来实现页面懒加载,通过 getBoundingClientRect 方法来获取元素的位置信息,当元素的位置信息与视口的位置信息发生交叉时,就加载元素
3. 通过监听 scroll 事件来实现页面懒加载,通过监听 scroll 事件来获取滚动条的位置,当滚动条的位置与元素的位置发生交叉时,就加载元素
4. 通过监听 wheel 事件来实现页面懒加载,通过监听 wheel 事件来获取滚轮的位置,当滚轮的位置与元素的位置发生交叉时,就加载元素,但只能在滚动鼠标滚轮时触发
5. 通过监听 touchmove 事件来实现页面懒加载,通过监听 touchmove 事件来获取触摸的位置,当触摸的位置与元素的位置发生交叉时,就加载元素,但只能在触摸屏幕时触发

# api 返回比较慢,如何优化

1. 通过设置超时时间来优化,通过设置超时时间来限制 api 的响应时间,当 api 的响应时间超过这个时间时,就会触发超时事件,可以通过设置超时时间来优化 api 的响应速度
2. 通过设置缓存来优化,对于更新不频繁的信息 通过设置缓存来缓存 api 的响应数据,当再次请求 api 时,可以直接从缓存中获取数据,而不用再次请求 api
3. 前端采用流式加载,通过前端采用流式加载的方式,可以提高 api 的响应速度,当 api 的响应数据量很大时,可以通过流式加载的方式,将数据分批次返回给前端,从而提高 api 的响应速度
4. 通过设置请求头来优化,通过设置请求头来优化 api 的响应速度,可以通过设置请求头的 Accept-Encoding 字段来告诉服务器,浏览器支持的压缩算法,服务器可以根据这个字段来压缩响应数据,从而提高 api 的响应速度
5. 后端服务器做分流代理转发给不同服务器
6. 提升服务器性能

# api 返回比较慢,可能是什么原因

1. 网络原因,网络延迟,网络拥堵,网络故障等
2. 服务器原因,服务器性能不足,服务器负载过高,服务器故障等
3. 数据库原因,数据库性能不足,数据库负载过高,数据库故障等
4. 代码原因,代码逻辑复杂,代码执行效率低,代码出现死循环等
5. 系统原因,系统资源不足,系统负载过高,系统故障等
6. 第三方原因,第三方服务响应慢,第三方服务故障等
7. 客户端原因,客户端性能不足,客户端负载过高,客户端故障等
8. 数据原因,数据量过大,数据处理复杂,数据处理效率低等
9. 环境原因,环境配置不当,环境资源不足,环境故障等
10. 安全原因,安全防护措施过多,安全防护措施过于严格等

# angular 和 react 区别

1. angular 是一个完整的框架,提供了一整套解决方案,包括模板引擎,路由,状态管理,依赖注入等,而 react 只是一个视图层框架,只提供了视图层的解决方案,其他功能需要通过第三方库来实现
2. angular 使用的是双向数据绑定,数据的变化会自动更新视图,而 react 使用的是单向数据流,数据的变化需要手动更新视图
3. angular 使用的是模板引擎,模板引擎是一种将数据和视图进行绑定的方式,而 react 使用的是 jsx,jsx 是一种将 html 和 javascript 结合在一起的语法
4. angular 使用的是依赖注入,依赖注入是一种将依赖关系注入到组件中的方式,而 react 使用的是 props,props 是一种将数据传递给组件的方式

# 首屏时间相关指标

1. TTFB(Time To First Byte) 首字节时间,即浏览器发起请求到接收到第一个字节的时间,主要受服务器响应时间和网络延迟的影响
2. FCP(First Contentful Paint) 首次内容绘制,即浏览器绘制第一个像素的时间,主要受网络延迟和资源加载时间的影响
3. LCP(Largest Contentful Paint) 最大内容绘制,即浏览器绘制最大内容的时间,主要受网络延迟和资源加载时间的影响
4. 白屏时间,即浏览器开始加载页面到页面开始显示内容的时间,主要受网络延迟和资源加载时间的影响
5. 首屏时间,即浏览器开始加载页面到页面显示完整内容的时间,主要受网络延迟和资源加载时间的影响
6. Performance API,通过 performance.timing 来获取页面加载时间,通过 performance.getEntries()来获取页面资源加载时间,通过 performance.memory 来获取页面内存使用情况
7. PerformanceObserver API,通过 performanceObserver.observe()来监听页面性能,通过 performanceObserver.disconnect()来停止监听页面性能
8. mutationObserver API,通过 mutationObserver 来监听页面 DOM 变化,通过 mutationObserver.observe()来监听页面 DOM 变化,通过 mutationObserver.disconnect()来停止监听页面 DOM 变化
9. lighthouse score 浏览器通过 lighthouse 来评估页面性能。
